module.exports = {


  friendlyName: 'Get vulnerabilities',


  description: 'Get sorted & paginated vulnerabilities that match the provided filters.',


  inputs: {

    minSeverity: {
      description: 'Optional filter to only get vulnerabilities whose `severity` is >= the specified value.',
      type: 'number',
      defaultsTo: 0,
    },

    maxSeverity: {
      description: 'Optional filter to only get vulnerabilities whose `severity` is <= the specified value.',
      type: 'number',
      defaultsTo: 10,
    },

    sortBy: {
      description: 'An optional facet to sort vulnerabilities by.',
      type: 'string',
      isIn: [
        'cveId',
        'severity',
        'hasKnownExploit',
        'publishedAt',
        'resolvedAt',
      ],
      defaultsTo: 'publishedAt'
    },

    sortDirection: {
      type: 'string',
      isIn: [
        'ASC',
        'DESC',
      ],
      defaultsTo: 'DESC'
    },

    page: {
      description: 'The zero-indexed page number.',
      type: 'number',
      defaultsTo: 0
    },

    pageSize: {
      description: 'The number of vulnerabilities to return per page',
      type: 'number',
      defaultsTo: 40,
    },

    teamApid: {
      description: 'The ID of the Team to filter by, or 0 to only include hosts with no team, or undefined to not filter by any team.',
      type: 'number',
    },

    cveId: {
      description: 'If provided, a report will be generated for only this CVE',
      type: 'string',
    }



  },

  exits: {

    success: {
      outputFriendlyName: 'Report',
      outputDescription: 'A dictionary with a `total` and `entries` (a list of vulnerabilities).',
      outputType: {},
      outputExample: {
        total: 1,
        entries: [
          { id: 99, /*…*/ }
        ]
      }
    },

    noMatchingVulnerabilities: {
      description: 'No vulnerabilities matching the provided filters were found.',
    },

  },


  fn: async function ({minSeverity, maxSeverity, sortBy, sortDirection, page, pageSize, teamApid, cveId}) {
    // console.time('Get vulnerabilities helper');

    let report = {};

    // If a specific CVE ID was provided, we'll change the where clause to only return information about that CVE.
    let whereClause;
    if(cveId){
      whereClause = { cveId };
    } else {
      whereClause = {
        and: [
          { severity: { '>=': minSeverity } },
          { severity: { '<=': maxSeverity } },
        ]
      };
    }//∞

    // console.log('Collecting vulnerabilities starting');
    // console.time('Collecting vulnerabilities');
    // This bit of code is performance-sensitive.

    // It gathers three pieces of information:
    //   - report.total (total # distinct cves)
    //   - hostConstraint (constraing with {in: list of matching host ids})
    //   - vulnerabilities (list of flat vuln records)
    let vulnerabilities;
    let hostConstraint = { nin: [] };
    if (teamApid === undefined) {
      report.total = await Vulnerability.count(whereClause);
      vulnerabilities = await Vulnerability.find(whereClause)
      .paginate(page, pageSize)
      .sort([
        { [sortBy]: sortDirection }
      ]);
      if(vulnerabilities.length === 0){
        throw 'noMatchingVulnerabilities';
      }
    } else {// If we're filtering by a specific team, we'll build a list of vulnerabilities that affect that team.
      // console.time('Host query');

      // other SQL query test
      let hostIdsToFind = _.pluck(await Host.find({teamApid: teamApid}).select(['id']), 'id');
      // TODO use parameterization
      let rawResultFromDatabase = await sails.sendNativeQuery(
        'SELECT * FROM  `vulnerability` '+
        'WHERE `id` IN ('+
          'SELECT `vulnerability` FROM `vulnerabilityinstall` '+
          'WHERE `host` IN ('+
            hostIdsToFind.join(',')+
          ')'+
        ');'
      );

      // quick sanity check
      // let queryTemplateArray = _.fill(Array(hostIdsToFind.length), '?');
      // sails.log('queryTemplateArray.length: '+queryTemplateArray.length);
      // sails.log(queryTemplateArray);
      // sails.log('hostIdsToFind.length: '+hostIdsToFind.length);
      // sails.log(hostIdsToFind);


      // let test = await sails.sendNativeQuery(
      //   'SELECT * FROM  `vulnerability` '+
      //   'WHERE `id` IN (SELECT `vulnerability` FROM `vulnerabilityinstall` '+
      //   'WHERE `host` IN ('+
      //   _.fill(Array(hostIdsToFind.length), '?').join(',')+
      //   '));',
      //   hostIdsToFind
      // );
      // sails.log(test);

      // Full SQL query test
      // let hostIdsToFind = _.pluck(await Host.find({teamApid: teamApid}).select(['id']), 'id');
      // sails.log(hostIdsToFind.length);
      // let test = await sails.sendNativeQuery(
      //   'select `vulnerability__vulnerabilities`.`createdAt`, `vulnerability__vulnerabilities`.`updatedAt`, `vulnerability__vulnerabilities`.`id`,'+ '`vulnerability__vulnerabilities`.`cveId`, `vulnerability__vulnerabilities`.`fleetSoftwareItemUrl`, `vulnerability__vulnerabilities`.`additionalDetailsUrl`,'+
      //   '`vulnerability__vulnerabilities`.`probabilityOfExploit`, `vulnerability__vulnerabilities`.`severity`, `vulnerability__vulnerabilities`.`hasKnownExploit`, '+
      //   '`vulnerability__vulnerabilities`.`publishedAt`,'+
      //   '`vulnerabilityinstall__vulnerabilities`.`host` as `_parent_fk` from `vulnerabilityinstall` as `vulnerabilityinstall__vulnerabilities`'+
      //   'left outer join `vulnerability` as `vulnerability__vulnerabilities` on `vulnerabilityinstall__vulnerabilities`.`vulnerability` = `vulnerability__vulnerabilities`.`id`'+
      //   'where `vulnerabilityinstall__vulnerabilities`.`host` in ('+
      //   hostIdsToFind.join(',')+
      //   ');'
      //   // hostIdsToFind
      // );

      // console.timeEnd('Host query');

      let vulnerabilitiesAffectingThisTeam = _.uniq(rawResultFromDatabase.rows, 'cveId');
      if(vulnerabilitiesAffectingThisTeam.length === 0){
        throw 'noMatchingVulnerabilities';
      }

      // Grab the host IDs
      // let filteredHostIds = _.pluck(hostsInThisTeam, 'id');

      // Sort the filtered array of vulnerabilities fot this team
      if(sortDirection === 'ASC') {
        vulnerabilities = _.sortBy(vulnerabilitiesAffectingThisTeam, sortBy);
      } else {
        vulnerabilities = _(_.sortBy(vulnerabilitiesAffectingThisTeam, sortBy)).reverse().value();
      }

      // Filter the array of vulnerabilities for this team using the provided minSeverity and maxSeverity.
      let filteredVulnerabilities = _.filter(vulnerabilities, (vuln)=>{
        return vuln.severity >= minSeverity && vuln.severity <= maxSeverity;
      });

      vulnerabilities = filteredVulnerabilities;
      hostConstraint = { in: hostIdsToFind };
      report.total = vulnerabilities.length;

      let startIndex = page * pageSize;
      let endIndex = startIndex + pageSize;
      let paginatedVulnerabilities = vulnerabilities.slice(startIndex, endIndex);
      vulnerabilities = paginatedVulnerabilities;
    }
    // console.timeEnd('Collecting vulnerabilities');

    // Get # affected hosts for each vulnerability
    // let liveInstallsFromEntireOrg = [];

    // Performance notes for VulnerabilityInstall model methods with 128892 VulnerabilityInstall records and 1105 host records
    // .find().populate('host') causes the app to hang and freezes the terminal when running locally
    // .find() without populate() takes 1-2 seconds
    // .stream().populate('host').eachBatch() takes ~13 seconds has no issues if the batch size is set to <4000
    // .stream() without populate takes ~3 seconds

    // console.time('Collecting live installs');
    // await VulnerabilityInstall.stream({
    //   uninstalledAt: 0,
    //   vulnerability: { in: _.pluck(vulnerabilities,'id') },
    // })
    // .populate('host')
    // .eachBatch(3000, async(records)=>{
    //   // TODO: optimize this
    //   liveInstallsFromEntireOrg = liveInstallsFromEntireOrg.concat(records);
    // });//∞


    let liveInstallsFromEntireOrg = await sails.sendNativeQuery(`
      SELECT * FROM vulnerabilityinstall 
      WHERE uninstalledAt = 0 AND vulnerability IN (`+
        _.pluck(vulnerabilities,'id').join(',')+//TODO use parameterization
      ')'
    );

    let hostsFromEntireOrg = await Host.find();

    for(let install of liveInstallsFromEntireOrg.rows){
      install.host = _.find(hostsFromEntireOrg, {id: install.host});
      if(!install.host){
        throw new Error(`Error: when mapping host records to VulnerabilityInstall records, a VulnerabilityInstall (id: ${install.id}) was found that is missing a "host" value! This is the database record that is missing a host: ${install}`);
      }
    }//∞

    // console.timeEnd('Collecting live installs');


    // sails.log(`Looping through ${vulnerabilities.length} vulnerabilities to add numAffectedHosts, affectedSoftware, affectedHosts, and affectedTeams`);
    // console.time('simultaneouslyForEach');

    // Add numAffectedHosts, resolvedAt, affectedTeams, and affectedHosts to each vulnerability in the report.
    await sails.helpers.flow.simultaneouslyForEach(vulnerabilities, async (vulnerability)=>{
      let theseLiveInstalls = [];
      if(teamApid === undefined) {
        theseLiveInstalls = _.where(liveInstallsFromEntireOrg.rows, {vulnerability: vulnerability.id});
      } else {
        theseLiveInstalls = _.where(liveInstallsFromEntireOrg.rows, {vulnerability: vulnerability.id, host: { teamApid: teamApid } });
      }

      // Because the same vuln can apply to the same host multiple different times through different software versions
      // this list of installs could contain the same host more than once.  So when we grab the host IDs, we'll also deduplicate them to produce our count.

      vulnerability.numAffectedHosts = _.uniq(_.pluck(theseLiveInstalls, 'host')).length;

      // if(vulnerability.id % 500 === 0){
      //   console.timeLog('simultaneouslyForEach');
      // }
      // Get resolution timestamp for each vulnerability.
      // (Or 0 if unresolved vulnerabilities are still installed on the hosts.)
      if (theseLiveInstalls.length >= 1) {
        vulnerability.resolvedAt = 0;
        let affectedInstalls = [];
        for (let install of theseLiveInstalls){
          affectedInstalls.push({name: install.softwareName, version:install.versionName, fleetApid: install.fleetApid, url: sails.config.custom.fleetBaseUrl+'/software/'+install.fleetApid, affectedHost: install.host.id, installedAt: install.installedAt});
        }
        vulnerability.affectedInstalls = affectedInstalls;
        vulnerability.affectedSoftware = _.uniq(affectedInstalls, 'fleetApid');
      } else {
        // Return the timestamp of the last uninstallation of this vuln amongst these hosts.
        let recentResolvedInstalls = await VulnerabilityInstall.find({
          uninstalledAt: { '!=': 0 },
          host: hostConstraint,
          vulnerability: vulnerability.id
        })
        .sort('uninstalledAt DESC').limit(1);
        if (!recentResolvedInstalls[0]) {
          sails.log.verbose(`Expected vulnerability ${vulnerability.cveId} (id: ${vulnerability.id}) with no unresolved installs to have a history of at least one resolved install.  Otherwise, why is it here?`);
          vulnerability.resolvedAt = 0;
        } else {
          vulnerability.resolvedAt = recentResolvedInstalls[0].uninstalledAt;
        }
      }//∞

      // Add affected teams and hosts
      vulnerability.affectedTeams = _.uniq(_.pluck(theseLiveInstalls, 'host.teamDisplayName'));
      vulnerability.affectedHosts = _.uniq(_.pluck(theseLiveInstalls, 'host'));
    });//∞

    // console.timeEnd('simultaneouslyForEach');
    // console.timeEnd('Get vulnerabilities helper');


    report.entries = vulnerabilities;
    return report;
  }


};

