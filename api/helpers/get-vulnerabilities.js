module.exports = {


  friendlyName: 'Get vulnerabilities',


  description: 'Get sorted & paginated vulnerabilities that match the provided filters.',


  inputs: {

    minSeverity: {
      description: 'Optional filter to only get vulnerabilities whose `severity` is >= the specified value.',
      type: 'number',
      defaultsTo: 0,
    },

    maxSeverity: {
      description: 'Optional filter to only get vulnerabilities whose `severity` is <= the specified value.',
      type: 'number',
      defaultsTo: 10,
    },

    sortBy: {
      description: 'An optional facet to sort vulnerabilities by.',
      type: 'string',
      isIn: [
        'cveId',
        'severity',
        'hasKnownExploit',
        'publishedAt',
        'resolvedAt',
      ],
      defaultsTo: 'publishedAt'
    },

    sortDirection: {
      type: 'string',
      isIn: [
        'ASC',
        'DESC',
      ],
      defaultsTo: 'DESC'
    },

    page: {
      description: 'The zero-indexed page number.',
      type: 'number',
      defaultsTo: 0
    },

    pageSize: {
      description: 'The number of vulnerabilities to return per page',
      type: 'number',
      defaultsTo: 40,
    },

    teamApid: {
      description: 'The name of the Team to filter by',
      type: 'number',
    },

    cveId: {
      description: 'If provided, a report will be generated for only this CVE',
      type: 'string',
    }



  },

  exits: {

    success: {
      outputFriendlyName: 'Report',
      outputDescription: 'A dictionary with a `total` and `entries` (a list of vulnerabilities).',
      outputType: {},
      outputExample: {
        total: 1,
        entries: [
          { id: 99, /*…*/ }
        ]
      }
    },

  },


  fn: async function ({minSeverity, maxSeverity, sortBy, sortDirection, page, pageSize, teamApid, cveId}) {

    let report = {};

    let hosts = await Host.find().populate('vulnerabilities');


    let whereClause = {
      and: [
        { severity: { '>=': minSeverity } },
        { severity: { '<=': maxSeverity } },
      ]
    };
    // If a specific CVE ID was provided, we'll change the where clause to only return information about that CVE.
    if(cveId){
      whereClause = { cveId };
    }
    let vulnerabilities;

    let hostConstraint = { nin: [] };
    // If we're filtering by a specific team, we'll build a list of vulnerabilities that affect that team.
    if (teamApid && teamApid !== 'undefined') {
      // Build a filtered array of hosts in this team
      let hostsInThisTeam = _.filter(hosts, { 'teamApid': teamApid });

      // Grab the host IDs
      let filteredHostIds = _.pluck(hostsInThisTeam, 'id');

      // Sort the filtered array of vulnerabilities fot this team
      if(sortDirection === 'ASC') {
        vulnerabilities = _.sortBy(_.uniq(_.pluck(hostsInThisTeam, 'vulnerabilities'))[0], sortBy);
      } else {
        vulnerabilities = _(_.sortBy(_.uniq(_.pluck(hostsInThisTeam, 'vulnerabilities'))[0], sortBy)).reverse().value();
      }

      // Filter the array of vulnerabilities for this team using the provided minSeverity and maxSeverity.
      let filteredVulnerabilities = _.filter(vulnerabilities, (vuln)=>{
        return vuln.severity >= minSeverity && vuln.severity <= maxSeverity;
      });

      vulnerabilities = filteredVulnerabilities;
      hostConstraint = { in: filteredHostIds };
      report.total = vulnerabilities.length;

      let startIndex = page * pageSize;
      let endIndex = startIndex + pageSize;
      let paginatedVulnerabilities = vulnerabilities.slice(startIndex, endIndex);
      vulnerabilities = paginatedVulnerabilities;
    } else {
      report.total = await Vulnerability.count(whereClause);
      vulnerabilities = await Vulnerability.find(whereClause)
      .paginate(page, pageSize)
      .sort([
        { [sortBy]: sortDirection }
      ]);

    }

    // Get # affected hosts for each vulnerability
    let liveInstalls = [];

    await VulnerabilityInstall.stream({
      uninstalledAt: 0,
      host: hostConstraint,
      vulnerability: { in: _.pluck(vulnerabilities,'id') },
    })
    .populate('host')
    .eachBatch(500, async(records)=>{
      liveInstalls = _.clone(liveInstalls).concat(records);
    });

    // Add numAffectedHosts, resolvedAt, affectedTeams, and affectedHosts to each vulnerability in the report.
    vulnerabilities.map(async (vulnerability)=>{
      let theseLiveInstalls = _.where(liveInstalls, {vulnerability: vulnerability.id});
      // Because the same vuln can apply to the same host multiple different times through different software versions
      // this list of installs could contain the same host more than once.  So when we grab the host IDs, we'll also deduplicate them to produce our count.
      vulnerability.numAffectedHosts = _.uniq(_.pluck(theseLiveInstalls, 'host.id')).length;

      // Get resolution timestamp for each vulnerability.
      // (Or 0 if unresolved vulnerabilities are still installed on the hosts.)
      if (theseLiveInstalls.length >= 1) {
        vulnerability.resolvedAt = 0;
        let affectedSoftware = [];
        for (let install of theseLiveInstalls){
          affectedSoftware.push({name: install.softwareName, version:install.versionName, url: sails.config.custom.fleetBaseUrl+'/software/'+install.fleetApid, affectedHost: install.host.id});
        }
        if(!cveId){
          vulnerability.affectedSoftware = _.uniq(affectedSoftware, 'version');
        } else {
        // If we're getting the affected software for a single vulnerability, we'll keep the original array of affectedSoftware.
          vulnerability.affectedSoftware = affectedSoftware;
        }
      } else {
        // Return the timestamp of the last uninstallation of this vuln amongst these hosts.
        let recentResolvedInstalls = await VulnerabilityInstall.find({
          uninstalledAt: { '!=': 0 },
          host: hostConstraint,
          vulnerability: vulnerability.id
        })
        .sort('uninstalledAt DESC').limit(1);
        if (!recentResolvedInstalls[0]) {
          sails.log.verbose(`Expected vulnerability ${vulnerability.cveId} (id: ${vulnerability.id}) with no unresolved installs to have a history of at least one resolved install.  Otherwise, why is it here?`);
          vulnerability.resolvedAt = 0;
        } else {
          vulnerability.resolvedAt = recentResolvedInstalls[0].uninstalledAt;
        }
      }//∞

      // Add affected teams and hosts
      vulnerability.affectedTeams = _.uniq(_.pluck(theseLiveInstalls, 'host.teamDisplayName'));
      if(cveId){
        vulnerability.affectedHosts = _.uniq(_.pluck(theseLiveInstalls, 'host'));
      } else {
        vulnerability.affectedHosts = _.uniq(_.pluck(theseLiveInstalls, 'host.displayName'));
      }
    });


    report.entries = vulnerabilities;

    return report;
  }


};

