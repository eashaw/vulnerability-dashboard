module.exports = {


  friendlyName: 'Get vulnerabilities',


  description: 'Get sorted & paginated vulnerabilities that match the provided filters.',


  inputs: {

    minSeverity: {
      description: 'Optional filter to only get vulnerabilities whose `severity` is >= the specified value.',
      type: 'number',
      defaultsTo: 0,
    },

    maxSeverity: {
      description: 'Optional filter to only get vulnerabilities whose `severity` is <= the specified value.',
      type: 'number',
      defaultsTo: 10,
    },

    sortBy: {
      description: 'An optional facet to sort vulnerabilities by.',
      type: 'string',
      isIn: [
        'cveId',
        'severity',
        'hasKnownExploit',
        'publishedAt',
        'resolvedAt',
      ],
      defaultsTo: 'publishedAt'
    },

    sortDirection: {
      type: 'string',
      isIn: [
        'ASC',
        'DESC',
      ],
      defaultsTo: 'DESC'
    },

    page: {
      description: 'The zero-indexed page number.',
      type: 'number',
      defaultsTo: 0
    },

    pageSize: {
      description: 'The number of vulnerabilities to return per page',
      type: 'number',
      defaultsTo: 40,
    },

    teamApid: {
      description: 'The ID of the Team to filter by, or 0 to only include hosts with no team, or undefined to not filter by any team.',
      type: 'number',
    },

    cveId: {
      description: 'If provided, a report will be generated for only this CVE',
      type: 'string',
    }



  },

  exits: {

    success: {
      outputFriendlyName: 'Report',
      outputDescription: 'A dictionary with a `total` and `entries` (a list of vulnerabilities).',
      outputType: {},
      outputExample: {
        total: 1,
        entries: [
          { id: 99, /*…*/ }
        ]
      }
    },

  },


  fn: async function ({minSeverity, maxSeverity, sortBy, sortDirection, page, pageSize, teamApid, cveId}) {
    console.time('Get vulnerabilities helper');

    let report = {};

    // If a specific CVE ID was provided, we'll change the where clause to only return information about that CVE.
    let whereClause;
    if(cveId){
      whereClause = { cveId };
    } else {
      whereClause = {
        and: [
          { severity: { '>=': minSeverity } },
          { severity: { '<=': maxSeverity } },
        ]
      };
    }//∞

    let vulnerabilities;
    console.log('Collecting vulnerabilities starting');
    console.time('Collecting vulnerabilities');
    let hostConstraint = { nin: [] };
    if (teamApid === undefined) {
      report.total = await Vulnerability.count(whereClause);
      vulnerabilities = await Vulnerability.find(whereClause)
      .paginate(page, pageSize)
      .sort([
        { [sortBy]: sortDirection }
      ]);
    } else {// If we're filtering by a specific team, we'll build a list of vulnerabilities that affect that team.
      //
      let hostsInThisTeam = await Host.find({ 'teamApid': teamApid })
      .limit(500)
      .populate('vulnerabilities');

      // Grab the host IDs
      let filteredHostIds = _.pluck(hostsInThisTeam, 'id');

      // Sort the filtered array of vulnerabilities fot this team
      if(sortDirection === 'ASC') {
        vulnerabilities = _.sortBy(_.uniq(_.pluck(hostsInThisTeam, 'vulnerabilities'))[0], sortBy);
      } else {
        vulnerabilities = _(_.sortBy(_.uniq(_.pluck(hostsInThisTeam, 'vulnerabilities'))[0], sortBy)).reverse().value();
      }

      // Filter the array of vulnerabilities for this team using the provided minSeverity and maxSeverity.
      let filteredVulnerabilities = _.filter(vulnerabilities, (vuln)=>{
        return vuln.severity >= minSeverity && vuln.severity <= maxSeverity;
      });

      vulnerabilities = filteredVulnerabilities;
      hostConstraint = { in: filteredHostIds };
      report.total = vulnerabilities.length;

      let startIndex = page * pageSize;
      let endIndex = startIndex + pageSize;
      let paginatedVulnerabilities = vulnerabilities.slice(startIndex, endIndex);
      vulnerabilities = paginatedVulnerabilities;
    }
    console.timeEnd('Collecting vulnerabilities');

    // Get # affected hosts for each vulnerability
    let liveInstalls = [];

    // Performance notes for VulnerabilityInstall model methods with 128892 VulnerabilityInstall records and 1105 host records
    // .find().populate('host') causes the app to hang and freezes the terminal when running locally
    // .find() without populate() takes 1-2 seconds
    // .stream().populate('host').eachBatch() takes ~13 seconds has no issues if the batch size is set to <4000
    // .stream() without populate takes ~3 seconds
    // Note: Even through using .stream().populate('host') takes 10 seconds longer, the 

    console.time('Collecting live installs');
    await VulnerabilityInstall.stream({
      uninstalledAt: 0,
      host: hostConstraint,
      vulnerability: { in: _.pluck(vulnerabilities,'id') },
    })
    .populate('host')
    .eachBatch(5000, async(records)=>{
      // TODO: optimize this
      liveInstalls = liveInstalls.concat(records);
    });//∞
    console.timeEnd('Collecting live installs');
    sails.log(`Looping through ${vulnerabilities.length} vulnerabilities to add numAffectedHosts, affectedSoftware, affectedHosts, and affectedTeams`);
    console.time('simultaneouslyForEach');
    // Add numAffectedHosts, resolvedAt, affectedTeams, and affectedHosts to each vulnerability in the report.
    await sails.helpers.flow.simultaneouslyForEach(vulnerabilities, async (vulnerability)=>{
      let theseLiveInstalls = _.where(liveInstalls, {vulnerability: vulnerability.id});
      // Because the same vuln can apply to the same host multiple different times through different software versions
      // this list of installs could contain the same host more than once.  So when we grab the host IDs, we'll also deduplicate them to produce our count.
      vulnerability.numAffectedHosts = _.uniq(_.pluck(theseLiveInstalls, 'host.id')).length;
      if(vulnerability.id % 500 === 0){
        console.timeLog('simultaneouslyForEach')
      }
      // Get resolution timestamp for each vulnerability.
      // (Or 0 if unresolved vulnerabilities are still installed on the hosts.)
      if (theseLiveInstalls.length >= 1) {
        vulnerability.resolvedAt = 0;
        let affectedSoftware = [];
        for (let install of theseLiveInstalls){
          affectedSoftware.push({name: install.softwareName, version:install.versionName, url: sails.config.custom.fleetBaseUrl+'/software/'+install.fleetApid, affectedHost: install.host.id});
        }
        if(!cveId){
          vulnerability.affectedSoftware = _.uniq(affectedSoftware, 'version');
        } else {
        // If we're getting the affected software for a single vulnerability, we'll keep the original array of affectedSoftware.
          vulnerability.affectedSoftware = affectedSoftware;
        }
      } else {
        // Return the timestamp of the last uninstallation of this vuln amongst these hosts.
        let recentResolvedInstalls = await VulnerabilityInstall.find({
          uninstalledAt: { '!=': 0 },
          host: hostConstraint,
          vulnerability: vulnerability.id
        })
        .sort('uninstalledAt DESC').limit(1);
        if (!recentResolvedInstalls[0]) {
          sails.log.verbose(`Expected vulnerability ${vulnerability.cveId} (id: ${vulnerability.id}) with no unresolved installs to have a history of at least one resolved install.  Otherwise, why is it here?`);
          vulnerability.resolvedAt = 0;
        } else {
          vulnerability.resolvedAt = recentResolvedInstalls[0].uninstalledAt;
        }
      }//∞

      // Add affected teams and hosts
      vulnerability.affectedTeams = _.uniq(_.pluck(theseLiveInstalls, 'host.teamDisplayName'));
      if(cveId){
        vulnerability.affectedHosts = _.uniq(_.pluck(theseLiveInstalls, 'host'));
      } else {
        vulnerability.affectedHosts = _.uniq(_.pluck(theseLiveInstalls, 'host.displayName'));
      }
    });//∞

    console.timeEnd('simultaneouslyForEach');
    console.timeEnd('Get vulnerabilities helper');


    report.entries = vulnerabilities;

    return report;
  }


};

