module.exports = {


  friendlyName: 'Get remediation timeline',


  description: 'Get snapshots of progress toward resolving the specified vulnerability.',


  inputs: {

    vulnerabilityId: {
      description: 'The vulnerability whose resolution progress we\'re examining.',
      type: 'number',
      required: true,
    },

    teamApid: {
      description: 'The team name',
      type: 'number',
    }

  },


  exits: {

    success: {
      outputType: [{}],
    },
  },


  fn: async function ({vulnerabilityId, teamApid}) {

    // Find the database record for this vulnerability
    let vulnerabilityRecord = await Vulnerability.findOne({id: vulnerabilityId}).populate('hosts').populate('installs');
    let affectedHosts = vulnerabilityRecord.hosts;
    let vulnInstalls = vulnerabilityRecord.installs;

    // If a teamApid was provided, we'll only show results for hosts in that team.
    if(teamApid) {
      let affectedFilteredHosts = _.filter(affectedHosts, { 'teamApid': teamApid });
      affectedHosts = affectedFilteredHosts;
    }

    // Create a new set to track the affected hosts as we build a remediation timeline.
    let affectedHostsOverTime = new Set();

    let numberOfHostsAffectedByTimestamp = vulnInstalls.reduce((uniqueVulnInstallsGroupedByDay, vulnInstall) => {
      // If a vulnInstall record has a uninstalledAt value, we'll exclude it from this timeline item.
      if (vulnInstall.uninstalledAt !== 0) {
        affectedHostsOverTime.delete(vulnInstall.host);
        return uniqueVulnInstallsGroupedByDay;
      }
      affectedHostsOverTime.add(vulnInstall.host);
      // Find any items that have an installedAt value within a half hour of this item's installedAt value.
      let existingItem = uniqueVulnInstallsGroupedByDay.find(item => Math.abs(item.installedAt - vulnInstall.installedAt) < 60 * 60 * 24 * 1000);
      if (existingItem) {
        // If there was an existing object for this hour, we'll add the host to the array of hosts, and update the number of hosts affected
        existingItem.hosts = new Set(affectedHostsOverTime);
        existingItem.hosts.add(vulnInstall.host);
        existingItem.numberOfHostsAffected = existingItem.hosts.size;
      } else {
        // If this is a new timestamp, we'll add a new object to the final array.
        uniqueVulnInstallsGroupedByDay.push({
          installedAt: vulnInstall.installedAt,
          numberOfHostsAffected: affectedHostsOverTime.size,
          hosts: new Set([vulnInstall.host, ...affectedHostsOverTime])
        });
      }
      return uniqueVulnInstallsGroupedByDay;
    }, []);

    let timeline = [];
    let timelineId = 1;
    // After we have our array of numberOfHostsAffectedByTimestamp, we'll iterate through it and build a timeline for this vulnerability.
    for(let install of numberOfHostsAffectedByTimestamp) {
      let vulnTimelinePoint = {
        id: timelineId,
        createdAt: eval(install.installedAt),
        numAffectedHosts: install.numberOfHostsAffected
      };
      timeline.push(vulnTimelinePoint);
      timelineId++;
    }
    timeline = _.sortBy(timeline, 'createdAt');

    // Create a timeline object to give the user the current status.
    timeline.push({
      id: timelineId,
      createdAt: Date.now(),
      numAffectedHosts: affectedHostsOverTime.size,
    });


    return {
      timeline,
      affectedHosts,
    };

  }


};
