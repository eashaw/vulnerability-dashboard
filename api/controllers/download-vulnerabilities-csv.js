module.exports = {


  friendlyName: 'Download vulnerabilities csv',


  description: 'Download vulnerabilities csv file (returning a stream).',


  inputs: {

    minSeverity: {
      description: 'Optional filter to only get vulnerabilities whose `severity` is >= the specified value.',
      type: 'number',
      defaultsTo: 0,
    },

    maxSeverity: {
      description: 'Optional filter to only get vulnerabilities whose `severity` is <= the specified value.',
      type: 'number',
      defaultsTo: 10,
    },

    sortBy: {
      description: 'An optional facet to sort vulnerabilities by.',
      type: 'string',
      isIn: [
        'cveId',
        'severity',
        'hasKnownExploit',
        'publishedAt',
        'resolvedAt',
      ],
      defaultsTo: 'publishedAt'
    },

    sortDirection: {
      type: 'string',
      isIn: [
        'ASC',
        'DESC',
      ],
      defaultsTo: 'DESC'
    },

    page: {
      description: 'The zero-indexed page number.',
      type: 'number',
      defaultsTo: 0
    },

    teamApid: {
      description: 'The ID of the Team to filter by, or 9999 to include hosts with no team, or 0 to not filter by any team',
      type: 'number',
    },

    pageSize: {
      description: 'The number of vulnerabilities to export',
      type: 'number',
      defaultsTo: 9999,
    },

    includeSoftware: {
      description: 'If provided, additional columns will be added to the generated CSV for the names of affected software',
      type: 'boolean',
    },

    includeHosts: {
      description: 'If provided, additional columns will be added to the generated CSV for names of affected hosts',
      type: 'boolean',
    },

  },


  exits: {
    success: {
      outputFriendlyName: 'File',
      outputDescription: 'The streaming bytes of the file.',
      outputType: 'ref'
    },
  },


  fn: async function ({minSeverity, maxSeverity, sortBy, sortDirection, page, pageSize, teamApid, includeSoftware, includeHosts}) {

    let report = await sails.helpers.getVulnerabilities.with({minSeverity, maxSeverity, sortBy, sortDirection, page, pageSize, teamApid});
    let generatedCsv = 'CVE ID,Severity,Has known exploit,Publish date,Resolved Date,Number of Affected Hosts';

    let largestNumberOfAffectedHosts;
    let largestNumberOfAffectedSoftware;

    if(includeHosts) {
      largestNumberOfAffectedHosts = _.max(_.map(report.entries, (vuln)=>{
        return vuln.affectedHosts.length;
      }));
      // Add additional columns for affected software
      for(let i = 0; i <= largestNumberOfAffectedHosts - 1; i++){
        generatedCsv +=`,Affected host ${i + 1}`;
      }
    }

    if(includeSoftware) {
      largestNumberOfAffectedSoftware = _.max(_.map(report.entries, (vuln)=>{
        return vuln.affectedSoftware.length;
      }));
      // Add additional columns for affected software
      for(let i = 0; i <= largestNumberOfAffectedSoftware - 1; i++){
        generatedCsv +=`,Affected software ${i + 1}`;
      }
    }

    generatedCsv += '\n';


    for(let vulnerability of report.entries){
      let strToAdd = `${vulnerability.cveId},${vulnerability.severity},${vulnerability.hasKnownExploit},${new Date(vulnerability.publishedAt)},${vulnerability.resolvedAt !== 0 ? new Date(vulnerability.resolvedAt) : 'N/A'},${vulnerability.numAffectedHosts}`;

      if(includeHosts) {
        for(let host of vulnerability.affectedHosts){
          strToAdd += `,${host}`;
        }
        for(let i = 1; i <= largestNumberOfAffectedHosts - vulnerability.affectedHosts.length; i++){
          strToAdd +=`,N/A`;
        }
      }
      if(includeSoftware) {
        for(let software of vulnerability.affectedSoftware){
          strToAdd += `,${software.name} @ ${software.version}`;
        }
        for(let i = 1; i <= largestNumberOfAffectedSoftware - vulnerability.affectedSoftware.length; i++){
          strToAdd +=`,N/A`;
        }
      }
      strToAdd += '\n';
      generatedCsv += strToAdd;
    }//âˆž
    // let exportISOTimestamp = (new Date()).toISOString();

    this.res.attachment(`export.csv`);
    this.res.set('text/csv')
    return generatedCsv;
  }


};
