module.exports = {


  friendlyName: 'Download vulnerabilities csv',


  description: 'Download vulnerabilities csv file (returning a stream).',


  inputs: {

    minSeverity: {
      description: 'Optional filter to only get vulnerabilities whose `severity` is >= the specified value.',
      type: 'number',
      defaultsTo: 0,
    },

    maxSeverity: {
      description: 'Optional filter to only get vulnerabilities whose `severity` is <= the specified value.',
      type: 'number',
      defaultsTo: 10,
    },

    sortBy: {
      description: 'An optional facet to sort vulnerabilities by.',
      type: 'string',
      isIn: [
        'cveId',
        'severity',
        'hasKnownExploit',
        'publishedAt',
        'resolvedAt',
      ],
      defaultsTo: 'publishedAt'
    },

    sortDirection: {
      type: 'string',
      isIn: [
        'ASC',
        'DESC',
      ],
      defaultsTo: 'DESC'
    },

    page: {
      description: 'The zero-indexed page number.',
      type: 'number',
      defaultsTo: 0
    },

    teamApid: {
      description: 'The ID of the Team to filter by, or 0 to only include hosts with no team, or undefined to not filter by any team.',
      type: 'number',
    },

    pageSize: {
      description: 'The number of vulnerabilities to export',
      type: 'number',
      defaultsTo: 9999,
    },

    includeHostsAndSoftware: {
      description: 'If provided, additional rows will be added to the generated CSV for each affected host.',
      type: 'boolean',
    },

  },


  exits: {
    success: {
      outputFriendlyName: 'File',
      outputDescription: 'The streaming bytes of the file.',
      outputType: 'ref'
    },
    emptyExport: {
      description: 'No matching vulnerabilities could be found with the provided filters',
      responseType: 'notFound',
    }
  },


  fn: async function ({minSeverity, maxSeverity, sortBy, sortDirection, page, pageSize, teamApid, includeHostsAndSoftware}) {

    let report = await sails.helpers.getVulnerabilities.with({minSeverity, maxSeverity, sortBy, sortDirection, page, pageSize, teamApid})
    .intercept('noMatchingVulnerabilities', (err)=>{
      return 'emptyExport';
    });


    let generatedCsv = 'CVE ID,Severity,Has known exploit,Publish date,Resolved Date,Number of affected hosts';

    if(includeHostsAndSoftware) {
      generatedCsv = 'CVE ID,Severity,Has known exploit,Publish date,Resolved Date,Affected software name,Affected software version,Affected software URL,Vulnerable software detected on,Host Fleet URL,Host display name,Host team,Host team ID';
    }

    generatedCsv += '\n';

    for(let vulnerability of report.entries) {
      let vulnString = `${vulnerability.cveId},${vulnerability.severity},${vulnerability.hasKnownExploit},${new Date(vulnerability.publishedAt)},${vulnerability.resolvedAt !== 0 ? new Date(vulnerability.resolvedAt) : 'N/A'},`;
      if(!includeHostsAndSoftware) {
        strToAdd = vulnString + `${vulnerability.numAffectedHosts}\n`
        generatedCsv += strToAdd;
      } else {
        for(let host of vulnerability.affectedHosts) {
          let installForThisHost = _.find(vulnerability.affectedInstalls, {affectedHost: host.id});
          let strToAdd = vulnString + `${installForThisHost.name},${!installForThisHost.version ? installForThisHost.version : 'N/A' },${installForThisHost.url},${new Date(installForThisHost.installedAt)},${sails.config.custom.fleetBaseUrl+'/hosts/'+encodeURIComponent(host.fleetApid)},${host.displayName},${host.teamDisplayName},${host.teamApid !== 0 ? host.teamApid : 'N/A'}`;
          strToAdd += '\n';
          generatedCsv += strToAdd;
        }
      }
    }//âˆž

    this.res.attachment(`export.csv`);
    this.res.set('text/csv');
    return generatedCsv;
  }


};
