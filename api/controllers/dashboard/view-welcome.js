module.exports = {


  friendlyName: 'View welcome page',


  description: 'Display the dashboard "Welcome" page.',


  exits: {

    success: {
      viewTemplatePath: 'pages/dashboard/welcome',
      description: 'Display the welcome page for authenticated users.'
    },

  },


  fn: async function () {

    let realDataForGraphs = {};

    let vulnerabilities = await Vulnerability.find().populate('installs');
    let hosts = await Host.find().populate('vulnerabilities');

    // Create a filtered array of all vulnerabilities with no unresolved vulnerability installs.
    let resolvedVulnerabilities = vulnerabilities.filter((vuln)=>{
      let vulnerabilityHasUnresolvedInstalls = _.where(vuln.installs, {uninstalledAt: 0});
      return vulnerabilityHasUnresolvedInstalls.length === 0;
    });
    let fullyResolvedVulnerabilities = [];


    for(let vuln of resolvedVulnerabilities){
      // If the vulnerability has no install records, or has lower than critical severity, we'll ignore it.
      if(vuln.installs.length === 0 || vuln.severity < 9){
        continue;
      }
      // Get the latest uninstalledAt value from the array of installs
      let vulnFullyResolvedAt = _.max(_.pluck(vuln.installs, 'uninstalledAt'));
      let vulnerability = {
        cveId: vuln.cveId,
        resolvedAt: vulnFullyResolvedAt,
        daysToFullyResolve: (vuln.createdAt - vulnFullyResolvedAt) / (24 * 60 * 60 * 1000)
      };
      fullyResolvedVulnerabilities.push(vulnerability);
    }

    let hostsWithHighVulnerabilities = hosts.filter((host)=>{
      let hasHighVuln = false;
      for(let vulnerability of host.vulnerabilities) {
        if(vulnerability.severity < 9.0 && vulnerability.severity > 7.0){
          hasHighVuln = true;
        }
      }
      return !! hasHighVuln;
    });

    let hostsWithCriticalVulnerabilities = hosts.filter((host)=>{
      let hasCriticalVuln = false;
      for(let vulnerability of host.vulnerabilities) {
        if(vulnerability.severity > 9){
          hasCriticalVuln = true;
        }
      }
      return hasCriticalVuln;
    });


    let newPublishedVulns = vulnerabilities.filter((vuln)=>{
      return vuln.createdAt > Date.now() - (1000 * 60 * 60 * 48);
    });

    let newPublishedCriticalVulns = newPublishedVulns.filter((vuln)=>{
      return vuln.severity >= 9;
    });

    let newPublishedHighVulns = newPublishedVulns.filter((vuln)=>{
      return vuln.severity < 9 && vuln.severity >= 7;
    });

    realDataForGraphs.newPublishedVulnerabilities = {
      totalNumberOfNewVulnerabilities: newPublishedVulns.length > 0 ? newPublishedVulns.length : 0,
      numberOfNewCriticalVulnerabilities: newPublishedCriticalVulns.length > 0 ? newPublishedCriticalVulns.length : 0,
      numberOfNewHighVulnerabilities: newPublishedHighVulns.length > 0 ? newPublishedHighVulns.length : 0,
    };

    let percentageOfHostsWithHighVuln = Math.round((hostsWithHighVulnerabilities.length / hosts.length * 100).toFixed(2));
    let percentageOfHostsWithNoHighVuln = Math.round((hosts.length / hostsWithHighVulnerabilities.length  * 100).toFixed(2) - 100);
    let percentageOfHostsWithCriticalVuln = Math.round((hostsWithCriticalVulnerabilities.length / hosts.length * 100).toFixed(2));
    let percentageOfHostsWithNoCriticalVuln = Math.round((hosts.length / hostsWithCriticalVulnerabilities.length * 100).toFixed(2) - 100);

    realDataForGraphs.criticalVulnerabilityPercentage = [percentageOfHostsWithCriticalVuln, percentageOfHostsWithNoCriticalVuln];
    realDataForGraphs.highVulnerabilityPercentage = [percentageOfHostsWithHighVuln, percentageOfHostsWithNoHighVuln];


    let criticalSeverity = vulnerabilities.filter((vuln)=>{
      return vuln.severity >= 9;
    });
    let highSeverity = vulnerabilities.filter((vuln)=>{
      return vuln.severity <= 8.9 && vuln.severity >= 7.0;
    });
    let mediumSeverity = vulnerabilities.filter((vuln)=>{
      return vuln.severity <= 6.9 && vuln.severity >= 4.0;
    });
    let lowSeverity = vulnerabilities.filter((vuln)=>{
      return vuln.severity >= 0 && vuln.severity <= 3.9;
    });
    let unknownSeverity = vulnerabilities.filter((vuln)=>{
      return vuln.severity === 0;
    });

    realDataForGraphs.numberOfVulnsBySeverity = [criticalSeverity.length, highSeverity.length, mediumSeverity.length, lowSeverity.length, unknownSeverity.length];

    let timelineDatasets = {
      critical: [],
      high: [],
      medium: [],
      low: [],
      unknown: [],
    };
    // Get a timestamp of midnight (UTC) previous the sunday.
    let today = new Date();
    let lastSunday = new Date(today.getFullYear(), today.getMonth(), today.getDate() - today.getDay());
    let lastSundayAt = Date.UTC(lastSunday.getFullYear(), lastSunday.getMonth(), lastSunday.getDate());
    // Create a JS timestamp of
    let threeWeeksFromLastSundayAt = lastSundayAt - (3 * 7 * 24 * 60 * 60 * 1000);

    let remediationDataset = [];
    // Build graph datasets for the past 4 weeks.
    for(let i = 0; i <= 3; i++) {
      let weekToAdd = (i * (7 * 24 * 60 * 60 * 1000));
      // Create a JS timestamp for the start and end timestamps we're checking for this iteration.
      let weekStartsAt = threeWeeksFromLastSundayAt + weekToAdd;
      let weekEndsAt = threeWeeksFromLastSundayAt + weekToAdd + (7 * 24 * 60 * 60 * 1000);
      // Filter the array of fully resolved vulnerabilities to find vulnerabilities that were resolved during this time.
      let vulnerabilitiesFullyResolvedDuringThisTime = fullyResolvedVulnerabilities.filter((resolvedVulnerability)=>{
        return resolvedVulnerability.resolvedAt > weekStartsAt && resolvedVulnerability.resolvedAt < weekEndsAt;
      });

      // Find the average number of days that it took to fully resolve the vulnerabilities that were resolved during this week.
      let averageNumberOfCriticalVulnerabilitiesResolved = Math.round(_.sum(vulnerabilitiesFullyResolvedDuringThisTime, 'daysToFullyResolve') / vulnerabilitiesFullyResolvedDuringThisTime.length) * -1;
      // Create a datapoint for the remediation timeline that has the average number of vulnerabilities resolved, and a timestamp of the start of the week.
      let remediationDatapoint = {
        x: weekStartsAt,
        y: averageNumberOfCriticalVulnerabilitiesResolved > 0 ? averageNumberOfCriticalVulnerabilitiesResolved : 'N/A',
      };
      remediationDataset.push(remediationDatapoint);

      // Create a filtered array of all critical vulnerabilities that affected hosts during this time.
      let criticalVulnerabilitiesThisWeek = _.filter(criticalSeverity, (vulnerability)=>{
        return _.some(vulnerability.installs, (install) => { return install.installedAt < weekStartsAt;});
      });
      // Create a dataset for the graph for this week.
      let criticalDatasetForThisWeek = {
        x: weekStartsAt,
        y: criticalVulnerabilitiesThisWeek.length
      };
      timelineDatasets.critical.push(criticalDatasetForThisWeek);
      // High severity
      let numberOfHighVulnerabilitiesThisWeek = _.filter(highSeverity, (vulnerability)=>{
        return _.some(vulnerability.installs, (install) => { return install.installedAt < weekStartsAt;});
      });
      let highDatasetForThisWeek = {
        x: weekStartsAt,
        y: numberOfHighVulnerabilitiesThisWeek.length
      };
      timelineDatasets.high.push(highDatasetForThisWeek);
      // Medium severity
      let numberOfMediumVulnerabilitiesThisWeek = _.filter(mediumSeverity, (vulnerability)=>{
        return _.some(vulnerability.installs, (install) => { return install.installedAt < weekStartsAt;});
      });
      let mediumDatasetForThisWeek = {
        x: weekStartsAt,
        y: numberOfMediumVulnerabilitiesThisWeek.length
      };
      timelineDatasets.medium.push(mediumDatasetForThisWeek);
      // Low severity
      let numberOfLowVulnerabilitiesThisWeek = _.filter(lowSeverity, (vulnerability)=>{
        return _.some(vulnerability.installs, (install) => { return install.installedAt < weekStartsAt;});
      });
      let lowDatasetForThisWeek = {
        x: weekStartsAt,
        y: numberOfLowVulnerabilitiesThisWeek.length
      };
      timelineDatasets.low.push(lowDatasetForThisWeek);
      // Unknown severity
      let numberOfUnknownVulnerabilitiesThisWeek = _.filter(unknownSeverity, (vulnerability)=>{
        return _.some(vulnerability.installs, (install) => { return install.installedAt < weekStartsAt;});
      });
      let unknownDatasetForThisWeek = {
        x: weekStartsAt,
        y: numberOfUnknownVulnerabilitiesThisWeek.length
      };
      timelineDatasets.unknown.push(unknownDatasetForThisWeek);
    }

    // Add data points for the current state of the vulnerability timeline
    timelineDatasets.critical.push({x: Date.now(), y: criticalSeverity.length});
    timelineDatasets.high.push({x: Date.now(), y: highSeverity.length});
    timelineDatasets.medium.push({x: Date.now(), y: mediumSeverity.length});
    timelineDatasets.low.push({x: Date.now(), y: lowSeverity.length});
    timelineDatasets.unknown.push({x: Date.now(), y: unknownSeverity.length});

    realDataForGraphs.timelineDatasets = timelineDatasets;
    realDataForGraphs.remediationTimeline = remediationDataset;


    return {
      realDataForGraphs: {
        remediationTimeline: realDataForGraphs.remediationTimeline,
        timelineDatasets: realDataForGraphs.timelineDatasets,
        newPublishedVulnerabilities:realDataForGraphs.newPublishedVulnerabilities,//last 48 hours
        criticalVulnerabilityPercentage: realDataForGraphs.criticalVulnerabilityPercentage,
        highVulnerabilityPercentage: realDataForGraphs.highVulnerabilityPercentage,
        numberOfVulnsBySeverity: realDataForGraphs.numberOfVulnsBySeverity,
      }
    };

  }


};
