module.exports = {


  friendlyName: 'Update reports',


  description: '',


  inputs: {

    dry: {
      description: 'Do a dry run instead of actually modifying the database?',
      type: 'boolean',
      defaultsTo: false
    },

  },


  fn: async function ({ dry }) {

    let assert = require('assert');

    //  ┌─┐┌─┐┌┬┐┬ ┬┌─┐┬─┐  ┌─┐┌┐┌┌┬┐  ┌─┐┬─┐┌─┐┌─┐┌─┐┌─┐┌─┐  ┌─┐┬  ┌─┐┌─┐┌┬┐  ┌─┐┌─┐┬  ┌┬┐┌─┐┌┬┐┌─┐
    //  │ ┬├─┤ │ ├─┤├┤ ├┬┘  ├─┤│││ ││  ├─┘├┬┘│ ││  ├┤ └─┐└─┐  ├┤ │  ├┤ ├┤  │   ├─┤├─┘│   ││├─┤ │ ├─┤
    //  └─┘┴ ┴ ┴ ┴ ┴└─┘┴└─  ┴ ┴┘└┘─┴┘  ┴  ┴└─└─┘└─┘└─┘└─┘└─┘  └  ┴─┘└─┘└─┘ ┴   ┴ ┴┴  ┴  ─┴┘┴ ┴ ┴ ┴ ┴
    if (!sails.config.custom.fleetBaseUrl || !sails.config.custom.fleetApiToken) {
      throw new Error('sails.config.custom.fleetBaseUrl and sails.config.custom.fleetApiToken must both be provided.');
    }
    let fleetBaseUrl = sails.config.custom.fleetBaseUrl;
    let headers = {
      Authorization: `Bearer ${sails.config.custom.fleetApiToken}`
    };

    // Keep track of the latest vulnerabilities, hosts, and software seen in the Fleet scan.
    // We'll use these later to check if any records have gone missing.
    let byCveIdsSeenInLatestFleetScan = {};
    let byHostFleetApidsSeenInLatestFleetScan = {};
    let softwareInfoForVulnInstalls = {};
    // Now paginate over software items in the Fleet API, processing as we go along.
    // (This is to avoid overflowing RAM on the server, in the antogonistic case where are just bookoos of vulnerabilities for some reason.)
    let page = 0;
    let SOFTWARE_VERSIONS_PAGE_SIZE = 50;
    let numVulnerableWaresProcessed = 0;
    await sails.helpers.flow.until(async ()=>{

      // * * *
      // Load a page of vulnerable software versions.
      // [?] https://fleetdm.com/docs/using-fleet/rest-api#list-all-software
      // # requests == O(vulnerableSoftware / SOFTWARE_VERSIONS_PAGE_SIZE)
      let vulnerableWares;
      {
        let responseData = await sails.helpers.http.get.with({
          url: '/api/v1/fleet/software',
          data: { vulnerable: true, page: page, per_page: SOFTWARE_VERSIONS_PAGE_SIZE, order_key: 'name', order_direction: 'asc' },//eslint-disable-line camelcase
          baseUrl: fleetBaseUrl,
          headers
        })
        .timeout(15000);
        assert(undefined === responseData.software || _.isArray(responseData.software));
        if (!responseData.software) {// When pages of results are exhausted, bail.  (`responseData.software` is absent in that case)
          return true;
        }//•
        vulnerableWares = responseData.software;
      }//∫


      sails.log.info('Processing page #',page,'of Fleet vulnerability data (',vulnerableWares.length,'software items )');// sails.log.verbose(require('util').inspect(vulnerableWares,{depth:null}));

      // * * *
      // For each software version, look up affected hosts.
      // (i.e. they have this version of software installed)
      let hostApidsBySoftwareVersionApid = {};// « Save a mapping for use below.
      await sails.helpers.flow.simultaneouslyForEach(vulnerableWares, async(ware)=>{

        // Get hosts with this version of software installed.
        // [?] https://fleetdm.com/docs/using-fleet/rest-api#list-hosts
        // # requests == O(SOFTWARE_VERSIONS_PAGE_SIZE * (vulnerableSoftware / SOFTWARE_VERSIONS_PAGE_SIZE))
        let hosts;
        {
          let responseData = await sails.helpers.http.get.with({// FUTURE: Paginate this using `.until()` for further scalability, as needed.
            url: '/api/v1/fleet/hosts',
            data: { software_id: ware.id, order_key: 'hostname', order_direction: 'asc' },//eslint-disable-line camelcase
            baseUrl: fleetBaseUrl,
            headers
          }).timeout(15000).intercept({raw:{statusCode: 404}} , (error)=>{
            throw new Error(`When sending a request to the '/api/v1/fleet/hosts' API endpoint to get a filtered array of hosts with ${ware.name} ${ware.version} installed (software ID: ${ware.id}), the Fleet instance returned a 404 response when we expected it to return an array of ${ware.hosts_count} host(s).\n Response from Fleet instance: ${error.raw.body}`);
          });
          assert(_.isArray(responseData.hosts));
          assert(responseData.hosts.every((host) => _.isNumber(host.id)));
          hosts = responseData.hosts;
        }//∫

        hostApidsBySoftwareVersionApid[ware.id] = _.pluck(hosts, 'id');// Keep track of which hosts have this software installed, for use below w/ vulns.

        for (let host of hosts) {
          byHostFleetApidsSeenInLatestFleetScan[host.id] = {
            displayName: host.display_name,
            teamDisplayName: host.team_name !== null ? host.team_name : 'No team',
            teamApid: host.team_id !== null ? host.team_id : 99999, // Note: If the host is not a member of any team, we'll set this to 99999
            fleetApid: host.id
          };//∞
        }
      })
      .intercept((err)=>{
        sails.log.error('An error occurred in side the iteratee of a flow control function.  Due to an unresolved issue, these errors can be hard to dissect without code changes.  Just in case, this log message seeks to dump as much info as possible!\n','err',err,'\nerr.raw', err.raw);
        // // Since .raw isn't displayed in output again in Node ≥12, try to make the error better.
        if (err.code === 'E_INTERNAL_ERROR') {
          return err.raw;
        } else {
          return err;
        }
      });//∞  </each software version>


      // Unrecognized hosts? Save 'em to the database.
      let newRecordsForUnrecognizedHosts = []; {
        let recognizedHosts = await Host.find({ fleetApid: { in: Object.keys(byHostFleetApidsSeenInLatestFleetScan).map((key)=>Number(key)) } });
        let unrecognizedHostApids = _.difference(Object.keys(byHostFleetApidsSeenInLatestFleetScan).map((key)=>Number(key)), _.pluck(recognizedHosts, 'fleetApid'));
        assert(unrecognizedHostApids.every((apid) => _.isNumber(apid)));
        for (let apid of unrecognizedHostApids) {
          newRecordsForUnrecognizedHosts.push(byHostFleetApidsSeenInLatestFleetScan[apid]);
        }//∞
        for(let host of recognizedHosts) {
          if(host.teamDisplayName !== byHostFleetApidsSeenInLatestFleetScan[host.fleetApid].teamDisplayName || host.teamApid !== byHostFleetApidsSeenInLatestFleetScan[host.fleetApid].teamApid) {
            await Host.updateOne({fleetApid: host.fleetApid})
            .set({
              teamDisplayName: byHostFleetApidsSeenInLatestFleetScan[host.fleetApid].teamDisplayName,
              teamApid: byHostFleetApidsSeenInLatestFleetScan[host.fleetApid].teamApid,
            });
          }
        }
      }//∫

      if (dry) {
        sails.log.warn(`Dry run: ${newRecordsForUnrecognizedHosts.length} hosts were seemingly enrolled. (Fleet returned them in the API.)`);
        // console.log(`would have created ${newRecordsForUnrecognizedHosts.length}:`,require('util').inspect(newRecordsForUnrecognizedHosts,{depth:null}));
      } else {
        console.log(`Creating ${newRecordsForUnrecognizedHosts.length} host records… `);
        await Host.createEach(newRecordsForUnrecognizedHosts);
      }

      // * * *
      // Build a formatted, filtered set of the vulnerabilities returned by this scan.
      // These will be analyzed below and potentially written to the database.
      let potentiallyNewVulnRecords = [];
      let cveIdsBySoftwareVersionApid = {};// « for use below when creating vuln installation records
      for (let ware of vulnerableWares) {
        softwareInfoForVulnInstalls[ware.id] = {
          softwareName: ware.name,
          versionName: ware.version,
        };
        cveIdsBySoftwareVersionApid[ware.id] = [];
        for (let fleetVuln of ware.vulnerabilities) {
          assert(_.isObject(fleetVuln));

          cveIdsBySoftwareVersionApid[ware.id].push(fleetVuln.cve);

          if (!fleetVuln.cve_published) {
            sails.log.warn('Unrecognized CVE detected in Fleet:' + require('util').inspect(fleetVuln, {depth:null}), 'for a software with the ID of '+ware.id+'. This means that the data being used to hydrate the vulnerability data with additional info such as publish date is missing this particular CVE, even though it was reported in the results from scanning with Fleet.  For consistency, excluding this vulnerability from the Fleet scan results as if it was not detected.');
          } else if (!fleetVuln.cvss_score) {
            sails.log.verbose('Invalid CVSS score detected by Fleet:' + require('util').inspect(fleetVuln, {depth:null}), 'This might mean that the vulnerability is undergoing reanlysis. For now, this vulnerability will be treated as if it was not detected in the Fleet scan results.');
          } else {
            if (!_.any(potentiallyNewVulnRecords, {cveId: fleetVuln.cve})) {// Don't track duplicates
              potentiallyNewVulnRecords.push({
                cveId: fleetVuln.cve,
                fleetSoftwareItemUrl: `${fleetBaseUrl}/software/${encodeURIComponent(ware.id)}`,
                additionalDetailsUrl: fleetVuln.details_link,
                probabilityOfExploit: fleetVuln.epss_probability,
                severity: fleetVuln.cvss_score,
                hasKnownExploit: fleetVuln.cisa_known_exploit,
                publishedAt: new Date(fleetVuln.cve_published).getTime(),
              });
            }
          }
        }//∞
      }//∞

      // * * *
      // Determine any new vulns that need to be created, then create records for them!
      let $knownVulns = await Vulnerability.find({
        cveId: { in: _.pluck(potentiallyNewVulnRecords, 'cveId') }
      });
      let newlyDiscoveredCveIds = _.difference(_.pluck(potentiallyNewVulnRecords, 'cveId'), _.pluck($knownVulns, 'cveId'));
      let newlyDiscoveredVulns = [];
      for (let cveId of newlyDiscoveredCveIds) {
        newlyDiscoveredVulns.push(_.find(potentiallyNewVulnRecords, {cveId: cveId}));
      }//∞

      if (dry) {
        sails.log.warn(`Dry run: ${newlyDiscoveredCveIds.length} newly discovered vulnerabilities (CVEs) are available. (Fleet returned them in the API.)`);
      } else {
        sails.log(`Detected ${newlyDiscoveredCveIds.length} new vulnerabilities.  Saving...`);
        await Vulnerability.createEach(newlyDiscoveredVulns).fetch();
      }


      // * * *
      // Build a set of vuln installation records to be saved.
      let potentialVulnInstalls = [];
      let existingVulnInstalls = await VulnerabilityInstall.find({select: ['host', 'vulnerability']});
      for (let ware of vulnerableWares) {
        let $vulns = await Vulnerability.find({ cveId: { in: cveIdsBySoftwareVersionApid[ware.id] }});// FUTURE: optimize (O(n) queries)
        let $hosts = await Host.find({ fleetApid: { in: hostApidsBySoftwareVersionApid[ware.id] }});// FUTURE: optimize (O(n) queries)
        for (let $vuln of $vulns) {
          for (let $host of $hosts) {
            // If a VulnerabilityInstall record exists that has the same host and vulnerability as the one we detected, we'll ignore it.
            let vulnInstallExists = _.find(existingVulnInstalls, {vulnerability: $vuln.id, host: $host.id});
            if(!vulnInstallExists){
              potentialVulnInstalls.push({
                installedAt: Date.now(),
                host: $host.id,
                vulnerability: $vuln.id,
                fleetApid: Number(ware.id),
                softwareName: softwareInfoForVulnInstalls[ware.id].softwareName,
                versionName: softwareInfoForVulnInstalls[ware.id].versionName,
              });
            }
          }//∞
        }//∞
      }//∞

      // console.log('****** potentialVulnInstalls *****',potentialVulnInstalls);

      if (dry) {
        sails.log.warn(`Dry run: ${potentialVulnInstalls.length} potential vulnerability installs are available.`);
      } else {
        sails.log(`Detected ${potentialVulnInstalls.length} changes to software installations.  Saving...`);
        let batchedPotentialVulnInstalls = _.chunk(potentialVulnInstalls, 1000);
        for(let batch of batchedPotentialVulnInstalls){
          await VulnerabilityInstall.createEach(batch);
        }
      }

      for (let vuln of potentiallyNewVulnRecords) {
        byCveIdsSeenInLatestFleetScan[vuln.cveId] = undefined;
      }//∞

      numVulnerableWaresProcessed += vulnerableWares.length;
      page++;

    })// (timeout after 10 minutes. TODO: Pull this from env VAR)
    .intercept((err)=> new Error('Could not get software from the Fleet API.  Error details: '+err));

    // sails.log('----------------------------');
    // sails.log('--  first part complete   --');
    // sails.log(`Object.keys(byCveIdsSeenInLatestFleetScan) (${Object.keys(byCveIdsSeenInLatestFleetScan).length}): `,Object.keys(byCveIdsSeenInLatestFleetScan));
    // sails.log(`Object.keys(byHostFleetApidsSeenInLatestFleetScan).map((key)=>Number(key)) (${Object.keys(byHostFleetApidsSeenInLatestFleetScan).map((key)=>Number(key)).length}): `,Object.keys(byHostFleetApidsSeenInLatestFleetScan).map((key)=>Number(key)));
    // sails.log('----------------------------');


    //  ┬─┐┌─┐┌─┐┌─┐┌┬┐  ┌┬┐┌─┐  ┬─┐┌─┐┌─┐┌─┐┬ ┬  ┬┌─┐┌┬┐  ┬  ┬┬ ┬┬  ┌┐┌┌─┐
    //  ├┬┘├┤ ├─┤│   │    │ │ │  ├┬┘├┤ └─┐│ ││ └┐┌┘├┤  ││  └┐┌┘│ ││  │││└─┐
    //  ┴└─└─┘┴ ┴└─┘ ┴    ┴ └─┘  ┴└─└─┘└─┘└─┘┴─┘└┘ └─┘─┴┘   └┘ └─┘┴─┘┘└┘└─┘
    //   ┬   ┌┬┐┬┌─┐┌─┐┬┌┐┌┌─┐  ┬ ┬┌─┐┌─┐┌┬┐┌─┐
    //  ┌┼─  ││││└─┐└─┐│││││ ┬  ├─┤│ │└─┐ │ └─┐
    //  └┘   ┴ ┴┴└─┘└─┘┴┘└┘└─┘  ┴ ┴└─┘└─┘ ┴ └─┘
    // * * *
    // Check for newly-fixed vulnerabilities.
    // (i.e. newly-fixed means previously-detected vulns that are no longer present)
    let newlyFixedVulns = [];
    // > Note: This could be further optimized for huge datasets to update vulnerabilities gradually
    // > as each batch is streamed.  But it really only matters when many many vulns are fixed all at
    // > once (i.e. `newlyFixedVulns`` overflowing).
    await Vulnerability.stream()
    .meta({batchSize: 1000})
    .eachRecord(($vuln)=>{
      if (!Object.keys(byCveIdsSeenInLatestFleetScan).includes($vuln.cveId)) {
        newlyFixedVulns.push($vuln);
      }
    });//∞
    if (dry) {
      sails.log.warn(`Dry run: ${newlyFixedVulns.length} previously-installed vulnerabilities were seemingly fixed. (Fleet did not return them in the API this time.)`);
    } else {
      await VulnerabilityInstall.update({ vulnerability: { in: _.pluck(newlyFixedVulns,'id') } }).set({
        uninstalledAt: Date.now()
      });
    }


    // * * *
    // Check for hosts in the database that are missing from the Fleet API.
    let missingHosts = [];
    await Host.stream()
    .meta({batchSize: 1000})
    .eachRecord(($host)=>{
      if (!Object.keys(byHostFleetApidsSeenInLatestFleetScan).map((key)=>Number(key)).includes($host.fleetApid)) {
        missingHosts.push($host);
      }
    });//∞
    if (dry) {
      sails.log.warn(`Dry run: ${missingHosts.length} previously-enrolled hosts seemingly unenrolled. (Fleet did not return them in the API this time.)`);
    } else {
      await VulnerabilityInstall.destroy({ host: { in: _.pluck(missingHosts,'id') } });
      await Host.destroy({ fleetApid: { in: _.pluck(missingHosts,'fleetApid') } });
    }

    //  ┌─┐┬  ┌─┐┌─┐┌┐┌  ┬ ┬┌─┐  ┬  ┬┬ ┬┬  ┌┐┌┌─┐┬─┐┌─┐┌┐ ┬┬  ┬┌┬┐┬┌─┐┌─┐  ┌┬┐┬ ┬┌─┐┌┬┐  ┬ ┬┌─┐┬  ┬┌─┐
    //  │  │  ├┤ ├─┤│││  │ │├─┘  └┐┌┘│ ││  │││├┤ ├┬┘├─┤├┴┐││  │ │ │├┤ └─┐   │ ├─┤├─┤ │   ├─┤├─┤└┐┌┘├┤
    //  └─┘┴─┘└─┘┴ ┴┘└┘  └─┘┴     └┘ └─┘┴─┘┘└┘└─┘┴└─┴ ┴└─┘┴┴─┘┴ ┴ ┴└─┘└─┘   ┴ ┴ ┴┴ ┴ ┴   ┴ ┴┴ ┴ └┘ └─┘
    //  ┌┐┌┌─┐  ┬┌┐┌┌─┐┌┬┐┌─┐┬  ┬  ┌─┐
    //  ││││ │  ││││└─┐ │ ├─┤│  │  └─┐
    //  ┘└┘└─┘  ┴┘└┘└─┘ ┴ ┴ ┴┴─┘┴─┘└─┘
    // * * *
    // Look for and destroy vulnerability records that have no hosts.
    let vulnerabilitiesWithNoHosts = [];

    await Vulnerability.stream()
    .populate('hosts')
    .meta({batchSize: 1000})
    .eachRecord(($vuln)=>{
      if ($vuln.hosts.length === 0) {
        vulnerabilitiesWithNoHosts.push($vuln);
      }
    });//∞
    if (dry) {
      sails.log.warn(`Dry run: ${vulnerabilitiesWithNoHosts.length} vulnerabilities that have no installs were found.`);
    } else {
      await Vulnerability.destroy({id: { in: _.pluck(vulnerabilitiesWithNoHosts, 'id')}});
    }

    // - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
    sails.log('Successfully completed scan and processing of',numVulnerableWaresProcessed,'vulnerable software items using Fleet.');
  }


};

