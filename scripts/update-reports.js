module.exports = {


  friendlyName: 'Update reports',


  description: '',


  inputs: {

    dry: {
      description: 'Do a dry run instead of actually modifying the database?',
      type: 'boolean',
      defaultsTo: false
    },

  },


  fn: async function ({ dry }) {



    let assert = require('assert');
    console.time('Update reports script');
    
    //  ┌─┐┌─┐┌┬┐┬ ┬┌─┐┬─┐  ┌─┐┌┐┌┌┬┐  ┌─┐┬─┐┌─┐┌─┐┌─┐┌─┐┌─┐  ┌─┐┬  ┌─┐┌─┐┌┬┐  ┌─┐┌─┐┬  ┌┬┐┌─┐┌┬┐┌─┐
    //  │ ┬├─┤ │ ├─┤├┤ ├┬┘  ├─┤│││ ││  ├─┘├┬┘│ ││  ├┤ └─┐└─┐  ├┤ │  ├┤ ├┤  │   ├─┤├─┘│   ││├─┤ │ ├─┤
    //  └─┘┴ ┴ ┴ ┴ ┴└─┘┴└─  ┴ ┴┘└┘─┴┘  ┴  ┴└─└─┘└─┘└─┘└─┘└─┘  └  ┴─┘└─┘└─┘ ┴   ┴ ┴┴  ┴  ─┴┘┴ ┴ ┴ ┴ ┴
    if (!sails.config.custom.fleetBaseUrl || !sails.config.custom.fleetApiToken) {
      throw new Error('sails.config.custom.fleetBaseUrl and sails.config.custom.fleetApiToken must both be provided.');
    }
    let fleetBaseUrl = sails.config.custom.fleetBaseUrl;
    let headers = {
      Authorization: `Bearer ${sails.config.custom.fleetApiToken}`
    };

    // Keep track of the latest vulnerabilities, hosts, and software seen in the Fleet scan.
    // We'll use these later to check if any records have gone missing.
    let byCveIdsSeenInLatestFleetScan = {};
    let byHostFleetApidsSeenInLatestFleetScan = {};
    let softwareInfoForVulnInstalls = {};
    // Now paginate over software items in the Fleet API, processing as we go along.
    // (This is to avoid overflowing RAM on the server, in the antogonistic case where are just bookoos of vulnerabilities for some reason.)
    let page = 0;
    let SOFTWARE_VERSIONS_PAGE_SIZE = 100;
    let numVulnerableWaresProcessed = 0;

    // Get an array of all existing VulnerabilityInstall records, but only grabing the host, vulenrability, and fleetApid. 
    // This will be used for checking for existing records when we process data from the Fleet API.
    // FUTURE: test if this can be optimized with a native SQL query.
    let $vulnInstalls = await VulnerabilityInstall.find();


    // let allKnownVulns = await Vulnerability.find();
    // let allKnownHosts = await Host.find(({select: ['id', 'fleetApid']}));


    //   ██████╗  ██████╗  ██████╗  ██████╗  ██████╗  ██████╗  ██████╗  ██████╗  ██████╗  ██████╗
    //  ██╔═══██╗██╔═══██╗██╔═══██╗██╔═══██╗██╔═══██╗██╔═══██╗██╔═══██╗██╔═══██╗██╔═══██╗██╔═══██╗
    //  ██║   ██║██║   ██║██║   ██║██║   ██║██║   ██║██║   ██║██║   ██║██║   ██║██║   ██║██║   ██║
    //  ██║   ██║██║   ██║██║   ██║██║   ██║██║   ██║██║   ██║██║   ██║██║   ██║██║   ██║██║   ██║
    //  ╚██████╔╝╚██████╔╝╚██████╔╝╚██████╔╝╚██████╔╝╚██████╔╝╚██████╔╝╚██████╔╝╚██████╔╝╚██████╔╝
    //
    //   ╚═════╝  ╚═════╝  ╚═════╝  ╚═════╝  ╚═════╝  ╚═════╝  ╚═════╝  ╚═════╝  ╚═════╝  ╚═════╝
    console.time('Ingest and process data from Fleet API');
    await sails.helpers.flow.until(async ()=>{
      console.time(`Page ${page} of vulnerable software from Fleet API`);
      // * * *
      // Load a page of vulnerable software versions.
      // [?] https://fleetdm.com/docs/using-fleet/rest-api#list-all-software
      // # requests == O(vulnerableSoftware / SOFTWARE_VERSIONS_PAGE_SIZE)
      let vulnerableWares;
      {
        let responseData = await sails.helpers.http.get.with({
          url: '/api/v1/fleet/software',
          data: { vulnerable: true, page: page, per_page: SOFTWARE_VERSIONS_PAGE_SIZE, order_key: 'name', order_direction: 'asc' },//eslint-disable-line camelcase
          baseUrl: fleetBaseUrl,
          headers
        })
        .timeout(30000);
        assert(undefined === responseData.software || _.isArray(responseData.software));
        if (!responseData.software) {// When pages of results are exhausted, bail.  (`responseData.software` is absent in that case)
          return true;
        }//•
        vulnerableWares = responseData.software;
      }//∫


      sails.log.info('Processing page #',page,'of Fleet vulnerability data (',vulnerableWares.length,'software items )');// sails.log.verbose(require('util').inspect(vulnerableWares,{depth:null}));

      // * * *
      // For each software version, look up affected hosts.
      // (i.e. they have this version of software installed)
      let hostApidsBySoftwareVersionApid = {};// « Save a mapping for use below.
      await sails.helpers.flow.simultaneouslyForEach(vulnerableWares, async(ware)=>{

        // Get hosts with this version of software installed.
        // [?] https://fleetdm.com/docs/using-fleet/rest-api#list-hosts
        // # requests == O(SOFTWARE_VERSIONS_PAGE_SIZE * (vulnerableSoftware / SOFTWARE_VERSIONS_PAGE_SIZE))
        let hosts;
        {
          let responseData = await sails.helpers.http.get.with({// FUTURE: Paginate this using `.until()` for further scalability, as needed.
            url: '/api/v1/fleet/hosts',
            data: { software_id: ware.id, order_key: 'hostname', order_direction: 'asc' },//eslint-disable-line camelcase
            baseUrl: fleetBaseUrl,
            headers
          })
          .timeout(30000)
          .intercept({raw:{statusCode: 404}} , (error)=>{
            return new Error(`When sending a request to the '/api/v1/fleet/hosts' API endpoint to get a filtered array of hosts with ${ware.name} ${ware.version} installed (software ID: ${ware.id}), the Fleet instance returned a 404 response when we expected it to return an array of ${ware.hosts_count} host(s).\n Response from Fleet instance: ${error.raw.body}`);
          });
          assert(_.isArray(responseData.hosts));
          assert(responseData.hosts.every((host) => _.isNumber(host.id)));
          hosts = responseData.hosts;
        }//∫

        hostApidsBySoftwareVersionApid[ware.id] = _.pluck(hosts, 'id');// Keep track of which hosts have this software installed, for use below w/ vulns.

        for (let host of hosts) {
          byHostFleetApidsSeenInLatestFleetScan[host.id] = {
            displayName: host.display_name,
            teamDisplayName: host.team_name !== null ? host.team_name : 'No team',
            teamApid: host.team_id !== null ? host.team_id : 0, // Note: If the host is not a member of any team, we'll set this to 0
            fleetApid: host.id,
          };//∞
        }
      }).intercept((err)=>{
        sails.log.error('An error occurred in side the iteratee of a flow control function.  Due to an unresolved issue, these errors can be hard to dissect without code changes.  Just in case, this log message seeks to dump as much info as possible!\n','err',err,'\nerr.raw', err.raw);
        // // Since .raw isn't displayed in output again in Node ≥12, try to make the error better.
        if (err.code === 'E_INTERNAL_ERROR') {
          return err.raw;
        } else {
          return err;
        }
      });//∞  </each software version>


      // Unrecognized hosts? Save 'em to the database.
      let newRecordsForUnrecognizedHosts = []; {
        let recognizedHosts = await Host.find({ fleetApid: { in: Object.keys(byHostFleetApidsSeenInLatestFleetScan).map((key)=>Number(key)) } });
        let unrecognizedHostApids = _.difference(Object.keys(byHostFleetApidsSeenInLatestFleetScan).map((key)=>Number(key)), _.pluck(recognizedHosts, 'fleetApid'));
        assert(unrecognizedHostApids.every((apid) => _.isNumber(apid)));
        for (let apid of unrecognizedHostApids) {
          newRecordsForUnrecognizedHosts.push(byHostFleetApidsSeenInLatestFleetScan[apid]);
        }//∞
        for(let host of recognizedHosts) {
          if(host.teamDisplayName !== byHostFleetApidsSeenInLatestFleetScan[host.fleetApid].teamDisplayName || host.teamApid !== byHostFleetApidsSeenInLatestFleetScan[host.fleetApid].teamApid) {
            await Host.updateOne({fleetApid: host.fleetApid})
            .set({
              teamDisplayName: byHostFleetApidsSeenInLatestFleetScan[host.fleetApid].teamDisplayName,
              teamApid: byHostFleetApidsSeenInLatestFleetScan[host.fleetApid].teamApid,
            });
          }
        }
      }//∫

      if (dry) {
        sails.log.warn(`Dry run: ${newRecordsForUnrecognizedHosts.length} hosts were seemingly enrolled. (Fleet returned them in the API.)`);
        // console.log(`would have created ${newRecordsForUnrecognizedHosts.length}:`,require('util').inspect(newRecordsForUnrecognizedHosts,{depth:null}));
      } else {
        sails.log(`Creating ${newRecordsForUnrecognizedHosts.length} host records… `);
        await Host.createEach(newRecordsForUnrecognizedHosts);
      }

      // * * *
      // Build a formatted, filtered set of the vulnerabilities returned by this scan.
      // These will be analyzed below and potentially written to the database.
      let potentiallyNewVulnRecords = [];
      let cveIdsBySoftwareVersionApid = {};// « for use below when creating vuln installation records
      for (let ware of vulnerableWares) {
        softwareInfoForVulnInstalls[ware.id] = {
          softwareName: ware.name,
          versionName: ware.version,
        };
        cveIdsBySoftwareVersionApid[ware.id] = [];
        for (let fleetVuln of ware.vulnerabilities) {
          assert(_.isObject(fleetVuln));

          cveIdsBySoftwareVersionApid[ware.id].push(fleetVuln.cve);

          if (!fleetVuln.cve_published) {
            // sails.log.warn('Unrecognized CVE detected in Fleet:' + require('util').inspect(fleetVuln, {depth:null}), 'for a software with the ID of '+ware.id+'. This means that the data being used to hydrate the vulnerability data with additional info such as publish date is missing this particular CVE, even though it was reported in the results from scanning with Fleet.  For consistency, excluding this vulnerability from the Fleet scan results as if it was not detected.');
          } else if (!fleetVuln.cvss_score) {
            // sails.log.verbose('Invalid CVSS score detected by Fleet:' + require('util').inspect(fleetVuln, {depth:null}), 'This might mean that the vulnerability is undergoing reanlysis. For now, this vulnerability will be treated as if it was not detected in the Fleet scan results.');
          } else {
            if (!_.any(potentiallyNewVulnRecords, {cveId: fleetVuln.cve})) {// Don't track duplicates
              potentiallyNewVulnRecords.push({
                cveId: fleetVuln.cve,
                fleetSoftwareItemUrl: `${fleetBaseUrl}/software/${encodeURIComponent(ware.id)}`,
                additionalDetailsUrl: fleetVuln.details_link,
                probabilityOfExploit: fleetVuln.epss_probability !== null ? fleetVuln.epss_probability : 0,// If the Fleet server sends this value as null, we'll set this to be 0.
                severity: fleetVuln.cvss_score,
                hasKnownExploit: fleetVuln.cisa_known_exploit,
                publishedAt: new Date(fleetVuln.cve_published).getTime(),
              });
            }
          }
        }//∞
      }//∞

      // * * *
      // Determine any new vulns that need to be created, then create records for them!
      // let $knownVulns = _.filter(allKnownVulns, (vuln)=>{return _.contains(_.pluck(potentiallyNewVulnRecords, 'cveId'), vuln.cveId)});
      let $knownVulns = await Vulnerability.find({
        cveId: { in: _.pluck(potentiallyNewVulnRecords, 'cveId') }
      });
      let newlyDiscoveredCveIds = _.difference(_.pluck(potentiallyNewVulnRecords, 'cveId'), _.pluck($knownVulns, 'cveId'));
      let newlyDiscoveredVulns = [];
      for (let cveId of newlyDiscoveredCveIds) {
        newlyDiscoveredVulns.push(_.find(potentiallyNewVulnRecords, {cveId: cveId}));
      }//∞

      if (dry) {
        sails.log.warn(`Dry run: ${newlyDiscoveredCveIds.length} newly discovered vulnerabilities (CVEs) are available. (Fleet returned them in the API.)`);
      } else {
        sails.log(`Detected ${newlyDiscoveredCveIds.length} new vulnerabilities.  Saving...`);
        await Vulnerability.createEach(newlyDiscoveredVulns).fetch();
      }


      // * * *
      // Build a set of vuln installation records to be saved.
      let potentialVulnInstalls = [];


      // Original approach.
      // Performance notes: 
      //  - Processing a software item with 2 vulnerabilities affecting 6807 hosts: 35.272s
      //  - Processing a software item with 30 vulnerabilities affecting 1199 hosts: 1m 50s
      let existingVulnInstalls = await VulnerabilityInstall.find({select: ['host', 'vulnerability']});

      for (let ware of vulnerableWares) {
        // console.time(`processed results for ware: ${ware.id}`);
        let $vulns = await Vulnerability.find({ cveId: { in: cveIdsBySoftwareVersionApid[ware.id] }});// FUTURE: optimize (O(n) queries)
        let $hosts = await Host.find({ fleetApid: { in: hostApidsBySoftwareVersionApid[ware.id] }});// FUTURE: optimize (O(n) queries)
        // console.log($vulns.length +' vulnerabilities, '+$hosts.length +' hosts');
        let existingVulnInstallsByHostAndVulnID = {};
        for(let $vulnInstall of existingVulnInstalls) {
          existingVulnInstallsByHostAndVulnID[`${$vulnInstall.vulnerability}|${$vulnInstall.host}`] = $vulnInstall;
        }
        for (let $vuln of $vulns) {
          for (let $host of $hosts) {
            // If a VulnerabilityInstall record exists that has the same host and vulnerability as the one we detected, we'll ignore it.

            let vulnInstallExists = existingVulnInstallsByHostAndVulnID[`${$vuln.id}|${$host.id}`];
            // _.find(existingVulnInstalls, {vulnerability: $vuln.id, host: $host.id});
            if(!vulnInstallExists){
            // if(false){
              potentialVulnInstalls.push({
                installedAt: Date.now(),
                host: $host.id,
                vulnerability: $vuln.id,
                fleetApid: Number(ware.id),
                softwareName: softwareInfoForVulnInstalls[ware.id].softwareName,
                versionName: softwareInfoForVulnInstalls[ware.id].versionName,
              });
            }
          }//∞
        }//∞
        // console.timeEnd(`processed results for ware: ${ware.id}`);
      }//∞



      // Vulnerable software processing performance notes:

      // Approach 1: 
      // Find all known hosts and vulnerabilities with a Waterline Model.find() method before we send requests to the Fleet API
      // Replace the Model.find() methods with _.filter()
      // performance notes:
      // - Processing a software item with 2 vulnerabilities affecting 6807 hosts: 3m 11s 
      // - Processing a software item with 30 vulnerabilities affecting 1199 hosts: >10m
      // 
      // for (let ware of vulnerableWares) {
      //   // console.time(`processed results for ware: ${ware.id}`);
      //   // Finding all vulnerabilities that have a cveId in the new array of cveIds
      //   let $vulns = _.filter(allKnownVulns, (vuln)=>{return _.contains(cveIdsBySoftwareVersionApid[ware.id], vuln.cveId)});
      //   // Finding all hosts that have a fleetApid in the array of host API ids
      //   let $hosts = _.filter(allKnownHosts, (host)=>{return _.contains(hostApidsBySoftwareVersionApid[ware.id], host.fleetApid)});
      //   // console.log($vulns.length +' vulnerabilities, '+$hosts.length +' hosts');
      //   for (let $vuln of $vulns) {
      //     for (let $host of $hosts) {
      //       // If a VulnerabilityInstall record exists that has the same host and vulnerability as the one we detected, we'll ignore it.
      //       let vulnInstallExists = _.find(allExistingVulnInstalls, {vulnerability: $vuln.id, host: $host.id, fleetApid: Number(ware.id)});
      //       if(!vulnInstallExists){
      //         potentialVulnInstalls.push({
      //           installedAt: Date.now(),
      //           host: $host.id,
      //           vulnerability: $vuln.id,
      //           fleetApid: Number(ware.id),
      //           softwareName: softwareInfoForVulnInstalls[ware.id].softwareName,
      //           versionName: softwareInfoForVulnInstalls[ware.id].versionName,
      //         });
      //       }
      //     }//∞
      //   }//∞
      //   // console.timeEnd(`processed results for ware: ${ware.id}`);
      // }//∞


      // Approach 2: Replacing the Model.find() methods with sails.sendNativeQuery(). 
      // (Note: These queries are in MySQL syntax and will need to be updated to be compatible with Postgres)
      // Results of update-reports test run: 
      //    - "Ingest and process data from Fleet API: 1:56:48.929 (h:mm:ss.mmm)" 
      //    - "Update reports script: 2:07:18.340 (h:mm:ss.mmm)"
      // Performance notes: 
      //  - Processing a software item with 2 vulnerabilities affecting 6807 hosts: 
      //  - Processing a software item with 30 vulnerabilities affecting 1199 hosts: 

      // for (let ware of vulnerableWares) {
      //   console.time(`Sending native SQL queries for ware: ${ware.id}`);
      //   let $vulns = await sails.sendNativeQuery(`
      //     SELECT * FROM vulnerability 
      //     WHERE cveId IN ("${cveIdsBySoftwareVersionApid[ware.id].join('","')}")`
      //   );
      //   let $hosts = await sails.sendNativeQuery(`
      //     SELECT * FROM host 
      //     WHERE fleetApid IN ("${hostApidsBySoftwareVersionApid[ware.id].join('","')}")`
      //   );
      //   console.timeEnd(`Sending native SQL queries for ware: ${ware.id}`);
      //   console.log($vulns.rows.length +' vulnerabilities, '+$hosts.rows.length +' hosts');
      //   console.time(`processed results for ware: ${ware.id}`);
      //   for (let $vuln of $vulns.rows) {
      //     for (let $host of $hosts.rows) {
      //       // If a VulnerabilityInstall record exists that has the same host and vulnerability as the one we detected, we'll ignore it.
      //       let vulnInstallExists = _.find(allExistingVulnInstalls, {vulnerability: $vuln.id, host: $host.id, fleetApid: Number(ware.id)});
      //       if(!vulnInstallExists){
      //         potentialVulnInstalls.push({
      //           installedAt: Date.now(),
      //           host: $host.id,
      //           vulnerability: $vuln.id,
      //           fleetApid: Number(ware.id),
      //           softwareName: softwareInfoForVulnInstalls[ware.id].softwareName,
      //           versionName: softwareInfoForVulnInstalls[ware.id].versionName,
      //         });
      //       }
      //     }//∞
      //   }//∞
      //   console.timeEnd(`processed results for ware: ${ware.id}`);
      // }//∞


      // Approach 3: Replacing only the vulnerability Model.find() method with a native SQL query, and replacing the Host.find()
      // with a _.filter() with an array of dictonaries containing Host IDs and fleetApids. This was done to prevent sending native SQL
      // queries to the database that can might have a WHERE clause containing >6k host IDs.
      // Performance results: 
      //  - Ingest and process data from Fleet API (first page): 8.847s
      //  - Ingest and process data from Fleet API (first 17 pages): 2hrs 31m 24s
      // 
      // for (let ware of vulnerableWares) {
      //   console.time(`processing results for software: ${ware.id}`);
      //   // (Note: This query are in MySQL syntax and will need to be updated to be compatible with Postgres)
      //   // Finding all vulnerabilities that have a cveId in the new array of cveIds
      //   let $vulns = await sails.sendNativeQuery(`
      //     SELECT * FROM vulnerability 
      //     WHERE cveId IN ("${cveIdsBySoftwareVersionApid[ware.id].join('","')}")`
      //   );
      //   // Finding all hosts that have a fleetApid in the array of host API ids
      //   let $hosts = _.filter(allKnownHosts, (host)=>{return _.contains(hostApidsBySoftwareVersionApid[ware.id], host.fleetApid)});
      //   console.log($vulns.rows.length +' vulnerabilities, '+$hosts.length +' hosts');
      //   for (let $vuln of $vulns.rows) {
      //     for (let $host of $hosts) {
      //       // If a VulnerabilityInstall record exists that has the same host and vulnerability as the one we detected, we'll ignore it.
      //       let vulnInstallExists = _.find(allExistingVulnInstalls, {vulnerability: $vuln.id, host: $host.id, fleetApid: Number(ware.id)});
      //       if(!vulnInstallExists){
      //         potentialVulnInstalls.push({
      //           installedAt: Date.now(),
      //           host: $host.id,
      //           vulnerability: $vuln.id,
      //           fleetApid: Number(ware.id),
      //           softwareName: softwareInfoForVulnInstalls[ware.id].softwareName,
      //           versionName: softwareInfoForVulnInstalls[ware.id].versionName,
      //         });
      //       }
      //     }//∞
      //   }//∞
      //   console.timeEnd(`processing results for software: ${ware.id}`);
      // }



      // Approach 4: Using native SQL queries and iterate through multiple software items at once using sails.helpers.flow.simultaneouslyForEach()
      // Performance notes:
      // 
      // await sails.helpers.flow.simultaneouslyForEach(vulnerableWares, async(ware)=>{
      //   console.time(`processed results for ware: ${ware.id}`);
      //   console.log(`processing results for ware: ${ware.id}`);
      //   let $vulns = await sails.sendNativeQuery(`
      //     SELECT * FROM vulnerability 
      //     WHERE cveId IN ("${cveIdsBySoftwareVersionApid[ware.id].join('","')}")`
      //   );
      //   let $hosts = await sails.sendNativeQuery(`
      //     SELECT * FROM host 
      //     WHERE fleetApid IN ("${hostApidsBySoftwareVersionApid[ware.id].join('","')}")`
      //   );
      //   console.log($vulns.rows.length +' vulnerabilities, '+$hosts.rows.length +' hosts');
      //   for (let $vuln of $vulns.rows) {
      //       for (let $host of $hosts.rows){
      //       // If a VulnerabilityInstall record exists that has the same host and vulnerability as the one we detected, we'll ignore it.
      //       let vulnInstallExists = _.find(allExistingVulnInstalls, {vulnerability: $vuln.id, host: $host.id, fleetApid: Number(ware.id)});
      //       if(!vulnInstallExists){
      //         potentialVulnInstalls.push({
      //           installedAt: Date.now(),
      //           host: $host.id,
      //           vulnerability: $vuln.id,
      //           fleetApid: Number(ware.id),
      //           softwareName: softwareInfoForVulnInstalls[ware.id].softwareName,
      //           versionName: softwareInfoForVulnInstalls[ware.id].versionName,
      //         });
      //       }
      //     };//∞
      //   }//∞
      //   console.timeEnd(`processed results for ware: ${ware.id}`);
      // });//∞



      // Approach 5:
      // Use native queries
      // replace the software loop with sails.helpers.flow.simultaneouslyForEach()
      // replace the host loop inside the vulnerability loop with sails.helpers.flow.simultaneouslyForEach()
      // 
      // Performance notes:
      //
      // await sails.helpers.flow.simultaneouslyForEach(vulnerableWares, async(ware)=>{
      //   console.time(`processed results for ware: ${ware.id}`);
      //   // console.log(`processing results for ware: ${ware.id}`);
      //   let $vulns = await sails.sendNativeQuery(`
      //     SELECT * FROM vulnerability 
      //     WHERE cveId IN ("${cveIdsBySoftwareVersionApid[ware.id].join('","')}")`
      //   );
      //   let $hosts = await sails.sendNativeQuery(`
      //     SELECT * FROM host 
      //     WHERE fleetApid IN ("${hostApidsBySoftwareVersionApid[ware.id].join('","')}")`
      //   );
      //   // console.log($vulns.rows.length +' vulnerabilities, '+$hosts.rows.length +' hosts');
      //   for (let $vuln of $vulns.rows) {
      //       await sails.helpers.flow.simultaneouslyForEach($hosts.rows, ($host)=>{
      //       // If a VulnerabilityInstall record exists that has the same host and vulnerability as the one we detected, we'll ignore it.
      //       let vulnInstallExists = _.find(allExistingVulnInstalls, {vulnerability: $vuln.id, host: $host.id, fleetApid: Number(ware.id)});
      //       if(!vulnInstallExists){
      //         potentialVulnInstalls.push({
      //           installedAt: Date.now(),
      //           host: $host.id,
      //           vulnerability: $vuln.id,
      //           fleetApid: Number(ware.id),
      //           softwareName: softwareInfoForVulnInstalls[ware.id].softwareName,
      //           versionName: softwareInfoForVulnInstalls[ware.id].versionName,
      //         });
      //       }
      //     });//∞
      //   }//∞
      //   console.timeEnd(`processed results for ware: ${ware.id}`);
      // });//∞

      // console.log('****** potentialVulnInstalls *****',potentialVulnInstalls);

      if (dry) {
        sails.log.warn(`Dry run: ${potentialVulnInstalls.length} potential vulnerability installs are available.`);
      } else {
        sails.log(`Detected ${potentialVulnInstalls.length} changes to software installations.  Saving...`);
        let batchedPotentialVulnInstalls = _.chunk(potentialVulnInstalls, 1000);
        for(let batch of batchedPotentialVulnInstalls){
          await VulnerabilityInstall.createEach(batch);
        }
      }

      for (let vuln of potentiallyNewVulnRecords) {
        byCveIdsSeenInLatestFleetScan[vuln.cveId] = undefined;
      }//∞

      numVulnerableWaresProcessed += vulnerableWares.length;
      console.timeEnd(`Page ${page} of vulnerable software from Fleet API`);
      page++;
      console.timeLog('Ingest and process data from Fleet API');
    }, 45 * 60 * 1000)// (timeout after 45 mintutes)
    .intercept((err) =>
      require('flaverr')({message: 'Could not get software from the Fleet API.  Error details: '+err.message}, err)
    );
    console.timeEnd('Ingest and process data from Fleet API');
    // sails.log('----------------------------');
    // sails.log('--  first part complete   --');
    // sails.log(`Object.keys(byCveIdsSeenInLatestFleetScan) (${Object.keys(byCveIdsSeenInLatestFleetScan).length}): `,Object.keys(byCveIdsSeenInLatestFleetScan));
    // sails.log(`Object.keys(byHostFleetApidsSeenInLatestFleetScan).map((key)=>Number(key)) (${Object.keys(byHostFleetApidsSeenInLatestFleetScan).map((key)=>Number(key)).length}): `,Object.keys(byHostFleetApidsSeenInLatestFleetScan).map((key)=>Number(key)));
    // sails.log('----------------------------');



    //   ██████╗  ██████╗  ██████╗  ██████╗  ██████╗  ██████╗  ██████╗  ██████╗  ██████╗  ██████╗
    //  ██╔═══██╗██╔═══██╗██╔═══██╗██╔═══██╗██╔═══██╗██╔═══██╗██╔═══██╗██╔═══██╗██╔═══██╗██╔═══██╗
    //  ██║   ██║██║   ██║██║   ██║██║   ██║██║   ██║██║   ██║██║   ██║██║   ██║██║   ██║██║   ██║
    //  ██║   ██║██║   ██║██║   ██║██║   ██║██║   ██║██║   ██║██║   ██║██║   ██║██║   ██║██║   ██║
    //  ╚██████╔╝╚██████╔╝╚██████╔╝╚██████╔╝╚██████╔╝╚██████╔╝╚██████╔╝╚██████╔╝╚██████╔╝╚██████╔╝
    //   ╚═════╝  ╚═════╝  ╚═════╝  ╚═════╝  ╚═════╝  ╚═════╝  ╚═════╝  ╚═════╝  ╚═════╝  ╚═════╝
    //
    console.time('React to resolved vulnerabilities');
    //  ┬─┐┌─┐┌─┐┌─┐┌┬┐  ┌┬┐┌─┐  ┬─┐┌─┐┌─┐┌─┐┬ ┬  ┬┌─┐┌┬┐  ┬  ┬┬ ┬┬  ┌┐┌┌─┐
    //  ├┬┘├┤ ├─┤│   │    │ │ │  ├┬┘├┤ └─┐│ ││ └┐┌┘├┤  ││  └┐┌┘│ ││  │││└─┐
    //  ┴└─└─┘┴ ┴└─┘ ┴    ┴ └─┘  ┴└─└─┘└─┘└─┘┴─┘└┘ └─┘─┴┘   └┘ └─┘┴─┘┘└┘└─┘
    //   ┬   ┌┬┐┬┌─┐┌─┐┬┌┐┌┌─┐  ┬ ┬┌─┐┌─┐┌┬┐┌─┐
    //  ┌┼─  ││││└─┐└─┐│││││ ┬  ├─┤│ │└─┐ │ └─┐
    //  └┘   ┴ ┴┴└─┘└─┘┴┘└┘└─┘  ┴ ┴└─┘└─┘ ┴ └─┘
    // * * *
    // Check for newly-fixed vulnerabilities.
    // (i.e. newly-fixed means previously-detected vulns that are no longer present)
    let newlyFixedVulns = [];
    // > Note: This could be further optimized for huge datasets to update vulnerabilities gradually
    // > as each batch is streamed.  But it really only matters when many many vulns are fixed all at
    // > once (i.e. `newlyFixedVulns`` overflowing).
    await Vulnerability.stream()
    .meta({batchSize: 1000})
    .eachRecord(($vuln)=>{
      if (!Object.keys(byCveIdsSeenInLatestFleetScan).includes($vuln.cveId)) {
        newlyFixedVulns.push($vuln);
      }
    });//∞
    if (dry) {
      sails.log.warn(`Dry run: ${newlyFixedVulns.length} previously-installed vulnerabilities were seemingly fixed. (Fleet did not return them in the API this time.)`);
    } else {
      sails.log(`${newlyFixedVulns.length} previously-installed vulnerabilities were seemingly fixed. (Fleet did not return them in the API this time.)`);
      await VulnerabilityInstall.update({ vulnerability: { in: _.pluck(newlyFixedVulns,'id') } }).set({
        uninstalledAt: Date.now()
      });
    }
    console.timeEnd('React to resolved vulnerabilities');


    console.time('React to missing hosts');
    // * * *
    // Check for hosts in the database that are missing from the Fleet API.
    let missingHosts = [];
    await Host.stream()
    .meta({batchSize: 1000})
    .eachRecord(($host)=>{
      if (!Object.keys(byHostFleetApidsSeenInLatestFleetScan).map((key)=>Number(key)).includes($host.fleetApid)) {
        missingHosts.push($host);
      }
    });//∞
    if (dry) {
      sails.log.warn(`Dry run: ${missingHosts.length} previously-enrolled hosts seemingly unenrolled. (Fleet did not return them in the API this time.)`);
    } else {
      sails.log(`${missingHosts.length} previously-enrolled hosts seemingly unenrolled. (Fleet did not return them in the API this time.)`)
      await VulnerabilityInstall.destroy({ host: { in: _.pluck(missingHosts,'id') } });
      await Host.destroy({ fleetApid: { in: _.pluck(missingHosts,'fleetApid') } });
    }
    console.timeEnd('React to missing hosts');
    //  ┌─┐┬  ┌─┐┌─┐┌┐┌  ┬ ┬┌─┐  ┬  ┬┬ ┬┬  ┌┐┌┌─┐┬─┐┌─┐┌┐ ┬┬  ┬┌┬┐┬┌─┐┌─┐  ┌┬┐┬ ┬┌─┐┌┬┐  ┬ ┬┌─┐┬  ┬┌─┐
    //  │  │  ├┤ ├─┤│││  │ │├─┘  └┐┌┘│ ││  │││├┤ ├┬┘├─┤├┴┐││  │ │ │├┤ └─┐   │ ├─┤├─┤ │   ├─┤├─┤└┐┌┘├┤
    //  └─┘┴─┘└─┘┴ ┴┘└┘  └─┘┴     └┘ └─┘┴─┘┘└┘└─┘┴└─┴ ┴└─┘┴┴─┘┴ ┴ ┴└─┘└─┘   ┴ ┴ ┴┴ ┴ ┴   ┴ ┴┴ ┴ └┘ └─┘
    //  ┌┐┌┌─┐  ┬┌┐┌┌─┐┌┬┐┌─┐┬  ┬  ┌─┐
    //  ││││ │  ││││└─┐ │ ├─┤│  │  └─┐
    //  ┘└┘└─┘  ┴┘└┘└─┘ ┴ ┴ ┴┴─┘┴─┘└─┘
    // * * *
    // Look for and destroy vulnerability records that have no hosts.
    console.time('Remove vulnerabilities that are resolved');
    let vulnerabilitiesWithNoHosts = [];

    await Vulnerability.stream()
    .populate('hosts')
    .meta({batchSize: 1000})
    .eachRecord(($vuln)=>{
      if ($vuln.hosts.length === 0) {
        vulnerabilitiesWithNoHosts.push($vuln);
      }
    });//∞
    if (dry) {
      sails.log.warn(`Dry run: ${vulnerabilitiesWithNoHosts.length} vulnerabilities that have no installs were found.`);
    } else {
      sails.log(`${vulnerabilitiesWithNoHosts.length} vulnerabilities that have no installs were found.`);
      await Vulnerability.destroy({id: { in: _.pluck(vulnerabilitiesWithNoHosts, 'id')}});
    }
    console.timeEnd('Remove vulnerabilities that are resolved');
    console.timeEnd('Update reports script');
    // - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
    sails.log('Successfully completed scan and processing of',numVulnerableWaresProcessed,'vulnerable software items using Fleet.');
  }


};

